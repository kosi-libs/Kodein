= Kodein DI on Ktor
Romain BOISSELLE <romain.boisselle@protonmail.com>
:toc: left
:toc-position: left
:toclevels: 5

:version: 6.1.0
:branch: 6.1

You can use Kodein as-is in your Ktor project, but you can go further by using the library `kodein-ktor`.

NOTE: Kodein does work on Ktor as-is.
      The `kodein-ktor` extension adds multiple ktor-specific utilities to Kodein. +
      Using or not using this extension really depends on your needs.

Have a look at the https://github.com/Kodein-Framework/Kodein-DI/tree/{branch}/demo/demo-ktor[Ktor demo project]!

[[install]]
== Install

.How to use `kodein-ktor`:
. Add this line in your `dependencies` block in your application `build.gradle` file:
+
[subs="attributes"]
----
implementation 'org.kodein.di:kodein-di-ktor-server-jvm:{version}'
----
+
IMPORTANT: Either `kodein-di-generic-jvm` or `kodein-di-erased-jvm` *must* be declared in addition to the Kodein-Ktor package.
+
. Using the `KodeinFeature`
+
As a Ktor `Application` is based on extensions it cannot be declared as `KodeinAware`.
So, we had to find another way to provide a global Kodein container. That's where the `KodeinFeature` stands.
It provides an instance of a Kodein container, that can potentially be accessed from anywhere in Ktor app.
+
[source, kotlin]
.Example: a Ktor Application declaration, installing the `KodeinFeature`
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        install(KodeinFeature) {
            /* bindings */
        }
   }.start(true)
}
----

. In your application, routes, etc. retrieve a Kodein object!

. Retrieve your dependencies!

== Retrieving

You can always get the `Kodein` object by using:

- `kodein()` inside a Ktor class (such as `Application`, `ApplicationCall`, `Route`, etc.)
- `kodein { application }` inside another class

CAUTION: The `kodein` function will only work if your Ktor `Application` has the `KodeinFeature` installed

== Ktor scopes

=== Session scopes

With the `kodein-ktor` utils you can scope your dependencies upon your Ktor sessions. To do that you'll have to follow the steps:

. Defining your session and scope your dependencies

[source, kotlin]
.Example: Defining the session and scope dependencies
----
data class UserSession(val user: User) : KtorSession { <1>
    override fun getSessionId() = user.id <2>
}

fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8000) {
        install(Sessions) { <3>
            cookie<UserSession>("SESSION_FEATURE_SESSION_ID") <4>
        }
        install(KodeinFeature) {
            bind<Random>() with scoped(SessionScope).singleton { SecureRandom() } <5>
            /* binding */
        }
    }.start(true)
}
----
<1> Create session object that implements `KtorSession`
<2> Implement the function `getSessionId()`
<3> Install the `Sessions` feature
<4> Declaring a session cookie represented by `UserSession`
<5> Bind `Random` object scoped by `SessionScope`

. Retrieving your scoped dependencies

[source, kotlin]
.Example: Retrieving scoped dependencies
----
embeddedServer(Netty, port = 8000) {
    /* configurations */
    routing {
        get("/random") {
            val session = call.sessions.get<UserSession>() ?: error("no session found!") <1>
            val random by kodein().on(session).instance<Random>() <2>
            call.responText("Hello ${session.user.name", your random number is ${random.nextInt()}")
        }
    }
}.start(true)
----
<1> Retrieve the `session` from the request context or fail
<2> retrieve a `Random` object from the `Kodein` object scoped by `session`

. Clear the scope as long as the sessions are no longer used

A Ktor session is cleared by calling the function `CurrentSession.clear<Session>()`.
To clear the session combine to the scope removal you can use the function `CurrentSession.clearSessionAndScope<Session>()`, 
thus the session will be cleared and the `ScopeRegistry` removed.

[source, kotlin]
.Example: Clear the session and scope
----
get("/clear") {
    call.sessions.clearSessionScope<UserSession>()
}
----
<1> clear the session and remove the `ScopeRegistry` linked to the session

=== Request scope

Kodein provides a standard scope for any object (Ktor or not).
The `WeakContextScope` will keep singleton and multiton instances as long as the context (= object) lives.

That's why the `RequestScope` is just a wrapper upon `WeakContextScope` with the target `ApplicationCall`, that lives only along the Request (HTTP or Websocket).

[source, kotlin]
.Example: using a Request scope
----
val kodein = Kodein {
    bind<Random>() with scoped(RequestScope).singleton { SecureRandom() } <1>
}
----
<1> A `Random` object will be created for each `Request` and will be retrieved as long as the `Request` lives.