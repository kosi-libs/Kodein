= KOtlin DEpendency INjection
Salomon BRYS <salomon.brys@gmail.com>
:toc: left
:toc-position: left
:toclevels: 5
:revdate: 2017-04-18

:version: 4.1.0
:branch: master

image::https://raw.githubusercontent.com/SalomonBrys/Kodein/{branch}/Kodein-logo.png[KODEIN, 700, 233]

image:https://img.shields.io/badge/Kotlin-1.1-blue.svg[alt="Kotlin 1.1.3-2", link="http://kotlinlang.org"]
image:https://img.shields.io/maven-central/v/com.github.salomonbrys.kodein/kodein.svg[alt="Maven Central", link="https://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.github.salomonbrys.kodein%22"]
image:https://img.shields.io/travis/SalomonBrys/Kodein.svg[alt="Travis", link="https://travis-ci.org/SalomonBrys/Kodein/builds"]
image:https://img.shields.io/github/license/salomonbrys/kodein.svg[alt="MIT License", link="https://github.com/SalomonBrys/Kodein/blob/{branch}/LICENSE.txt"]
image:https://img.shields.io/github/issues/SalomonBrys/Kodein.svg[alt="GitHub issues", link="https://github.com/SalomonBrys/Kodein/issues"]
image:https://img.shields.io/badge/Chat-Slack-green.svg[alt="Slack channel", link="https://kotlinlang.slack.com/messages/kodein/"]
image:https://img.shields.io/badge/Backing-Donate-orange.svg[alt="Donate", link="#_donate"]


== Introduction

=== Description

[.lead]
Kodein is a very useful dependency retrieval container, it is very easy to use and configure.

.Kodein allows you to:
- Lazily instantiate your dependencies when needed.
- Stop caring about dependency initialization order.
- Easily bind classes or interfaces to their instance, provider or factory.
- Easily debug your dependency bindings and recursions.

.Kodein is a good choice because:
- It is small, fast and optimized (makes extensive use of `inline`).
- It proposes a very simple and readable declarative DSL.
- It is not subject to type erasure (like Java).
- It integrates nicely with Android.
- It proposes a very kotlin-esque idiomatic API.
- It can be used in plain Java.


=== Example

[source,kotlin]
.An example is always better than a thousand words:
----
val kodein = Kodein {
    bind<Dice>() with provider { RandomDice(0, 5) }
    bind<DataSource>() with singleton { SqliteDS.open("path/to/file") }
}

class Controller(private val kodein: Kodein) {
    private val ds: DataSource = kodein.instance()
}
----


== Install

=== With Maven

[source,xml,subs="attributes"]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.github.salomonbrys.kodein&lt;/groupId&gt;
    &lt;artifactId&gt;kodein&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;
----


=== With Gradle

[source,groovy,subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein:{version}'
----


=== Using Proguard

If you are using Proguard, you need to add the following line to your proguard configuration file:

----
-keepattributes Signature
----


== Bindings: Declaring dependencies

[source,kotlin]
.Example: initialization of a Kodein variable
----
val kodein = Kodein {
	/* Bindings */
}
----

Bindings are declared inside a Kodein initialization block.

NOTE: By default, Kodein on the JVM is not subject to type erasure (e.g. You can bind both a `List<Int>` and a `List<String>` to different list instances, providers or factories).
      You can reffer to <<erased-by-default>> if you need an optimized version of Kodein that *is* subject to type erasure.


CAUTION: *Javascript IS subject to type erasure*.
         There are no present way to escape it.
         While the syntax will let you bind generic types such as `List<String>`, only the outer-most type (eg. `List`) will be registered in Kodein's engine.

A binding always starts with `bind<TYPE>() with ...`.

There are different ways to declare bindings:


=== Factory binding

This binds a type to a factory function, which is a function that takes an argument of a defined type and that returns an object of the bound type (eg. `(A) -> T`). +
The provided function will be called *each time* you need an instance of the bound type.

[source,kotlin]
.Example: creates a new Dice each time you need one, according to an Int representing the number of sides
----
val kodein = Kodein {
    bind<Dice>() with factory { sides: Int -> RandomDice(sides) }
}
----


=== Provider binding

This binds a type to a provider function, which is a function that takes no arguments and returns an object of the bound type (eg. `() -> T`). +
The provided function will be called *each time* you need an instance of the bound type.

[source,kotlin]
.Example: creates a new 6 sided Dice entry each time you need one
----
val kodein = Kodein {
    bind<Dice>() with provider { RandomDice(6) }
}
----


=== Singleton binding

This binds a type to an instance of this type that will lazily be created at first use via a singleton function, which is a function that takes no arguments and returns an object of the bound type (eg. `() -> T`). +
Therefore, the provided function will be called *only once*: the first time an instance is needed.

[source,kotlin]
.Example: creates a DataSource singleton that will be initialized on first access
----
val kodein = Kodein {
    bind<DataSource>() with singleton { SqliteDS.open("path/to/file") }
}
----


[[tagged-bindings]]
=== Tagged bindings

All bindings can be tagged to allow you to bind different instances of the same type.

[source,kotlin]
.Example: different Dice bindings
----
val kodein = Kodein {
    bind<Dice>() with factory { sides: Int -> RandomDice(sides) } // <1>
    bind<Dice>("DnD10") with provider { RandomDice(10) } // <2>
    bind<Dice>("DnD20") with singleton { RandomDice(20) } // <2>
}
----
<1> Default binding (with no tag)
<2> Bindings with tags (`"DnD10"` and `"DnD20"`)

IMPORTANT: You can have multiple bindings of the same type, as long as they are bound with different tags.
You can have only one binding of a certain type with no tag.

TIP: The tag is of type `Any`, it does not have to be a `String`.

IMPORTANT: Tag objects must support equality & hashcode comparison.
           It is therefore recommended to either use primitives (Strings, Ints, etc.) or data classes.


=== Eager singleton binding

This is the same as a regular singleton, except that the provided function will be called as soon as the Kodein instance is created and all bindings are defined.

[source,kotlin]
.Example: creates a DataSource singleton that will be initialized as soon as the binding block ends
----
val kodein = Kodein {
    // The SQLite connection will be opened as soon as the kodein instance is ready
    bind<DataSource>() with eagerSingleton { SqliteDS.open("path/to/file") }
}
----


=== Multiton binding

A multiton can be thought of a "singleton factory": it guarantees to always return the same object given the same argument.
In other words, for a given argument, the first time a multiton is called with this argument, it will call the function to create an instance; and will always yield that same instance when called with the same argument.

[source,kotlin]
.Example: creates one random generator for each value
----
val kodein = Kodein {
    bind<RandomGenerator>() with multiton { max: Int -> SecureRandomGenerator(max) }
}
----


=== Instance binding

This binds a type to an instance that *already exist*.

[source,kotlin]
.Example: a DataSource binding to an already existing instance.
----
val kodein = Kodein {
    bind<DataSource>() with instance(SqliteDataSource.open("path/to/file")) // <1>
}
----
<1> Instance is used *with parenthesis*: it is not given a function, but an instance.


=== Referenced singleton or multiton binding

A referenced singleton is an object that is guaranteed to be single as long as a reference object can return it.
A referenced multiton is an object that is guaranteed to be single for the same argument as long as a reference object can return it.

A referenced singleton or multiton needs a "reference maker" in addition to the classic construction funtion that determines the type of reference that will be used.

Kodein comes with three reference makers.

==== Soft & weak

These are objects that are guaranteed to be single in the JVM at a given time, but not guaranteed to be single during the application lifetime.
If there are no more strong references to the instances, they may be GC'd and later, re-created.

Therefore, the provided function *may or may not* be called multiple times during the application lifetime.

[source,kotlin]
.Example: creates an Cache object that will exist only once at a given time
----
val kodein = Kodein {
    bind<Cache>() with refSingleton(softReference) { LRUCache(16 * 1024) } <1>
}
----
<1> Because it's bound by a soft reference, the JVM will GC it before any `OutOfMemoryException` can occur.

Weak singletons use JVM's `WeakReference` while soft singletons use JVM's `SoftReference`.

CAUTION: Weak & soft references are not available in JavaScript.

==== Thread local

This is the same as the standard singleton binding, except that each thread gets a different instance.
Therefore, the provided function will be called *once per thread* that needs the instance, the first time it is requested.

[source,kotlin]
.Example: creates a Cache object that will exist once per thread
----
val kodein = Kodein {
    bind<Cache>() with refSingleton(threadLocal) { LRUCache(16 * 1024) }
}
----

NOTE: Semantically, thread local singletons should use <<scoped-singletons>>, the reason it uses a referenced singleton is because Java's `ThreadLocal` acts like a reference.

CAUTION: Thread locals are not available in JavaScript.


[[scoped-singletons]]
=== Scoped singletons

NOTE: Kodein does not provide scopes by default.
      Scoped singleton are used for extensions (such as Kodein-Android) and advanced usage.

==== Scoped singletons

Scoped singleton are singletons that are bound to a context and live while that context lives. +
The provided function will be called *once per context*.

[source, kotlin]
.Example: using a scope
----
val kodein = Kodein {
    bind<User>() with scopedSingleton(requestScope) { User(it.session) } // <1>
}
----
<1> `it` is the scope's context.

*Binding to a scoped singleton is similar to binding to a factory* where the argument is the context.
Therefore, when later retrieving an instance of type bound in a scoped singleton, the context will be needed.

==== Auto Scoped singletons

Auto scoped singletons are, from the binding's perspective, exactly similar to scoped singletons. +
The difference resides that, when retrieving an instance, the scope is responsible to providing the context.

Therefore, *binding to an auto scoped singleton is similar to binding to a provider*.


=== Constant binding

It is often useful to bind "configuration" constants.

NOTE: Constants are always <<tagged-bindings,tagged>>.

[source,kotlin]
.Example: two constants
----
val kodein = Kodein {
    constant("maxThread") with 8 // <1>
    constant("serverURL") with "https://my.server.url" // <1>
}
----
<1> Note the absence of curly braces: it is not given a function, but an instance.

CAUTION: You should only use constant bindings for very simple types without inheritance or interface (e.g. primitive types and data classes).


=== Direct binding

Sometimes, it may seem overkill to specify the type to `bind` if you are binding the same type as you are creating.

For this use case, you can transform any `bind<Type>() with binding` to `bind() from binding`.

[source,kotlin]
.Example: direct bindings
----
val kodein = Kodein {
    bind() from singleton { RandomDice(6) }
    bind("DnD20") from provider { RandomDice(20) }
    bind() from instance(SqliteDataSource.open("path/to/file"))
}
----

CAUTION: *This should be used with care* as binding a concrete class and, therefore, having concrete dependencies is an _anti-pattern_ that later prevents modularisation and mocking / testing.

WARNING: In the case of generic types, the bound type will be the specialized type, +
         e.g. `bind() from singleton { listOf(1, 2, 3, 4) }` registers the binding to `List<Int>`.


=== Transitive dependencies

With those lazily instantiated dependencies, a dependency (very) often needs another dependency.
Such object can have their dependencies passed to their constructor.
Thanks to Kotlin's killer type inference engine, Kodein makes retrieval of transitive dependencies really easy.

[source, kotlin]
.Example: a class that needs transitive dependencies
----
class Dice(private val random: Random, private val sides: Int) {
/*...*/
}
----

It is really easy to bind `RandomDice` with its transitive dependencies, by simply using `instance()` or `instance(tag)`.

[source, kotlin]
.Example: bindings of Dice and of its transitive dependencies
----
val kodein = Kodein {
    bind<Dice>() with singleton { Dice(instance(), instance("max")) } // <1>

    bind<Random>() with provider { SecureRandom() } // <2>
    constant("max") with 5 // <2>
}
----
<1> Binding of `Dice`. It gets its transitive dependencies by using `instance()` and `instance(tag)`.
<2> Bindings of `Dice` transitive dependencies.

NOTE: The order in which the bindings are declared has *no importance whatsoever*.


=== Being responsible for its own retrieval

You can pass the `kodein` object to the class so it can itself use the Kodein object to retrieve its own dependencies.

[source, kotlin]
.Example: bindings of Manager that is responsible for retrieving its own dependencies
----
val kodein = Kodein {
    bind<Manager>() with singleton { ManagerImpl(kodein) } // <1>
}
----
<1> ManagerImpl is given a Kodein instance.

See <<kodein-aware>> for how the class can retrieve its own dependencies.


== Bindings separation

=== Modules

Kodein allows you to export your bindings in modules.
It is very useful to have separate modules defining their own bindings instead of having only one central binding definition.
A module is an object that you can construct the exact same way as you construct a Kodein instance.


[source, kotlin]
.Example: a simple module
----
val apiModule = Kodein.Module {
    bind<API>() with singleton { APIImpl() }
    /* other bindings */
}
----

Then, in your Kodein binding block:

[source, kotlin]
.Example: imports the module
----
val kodein = Kodein {
    import(apiModule)
    /* other bindings */
}
----

NOTE: Modules are *definitions*, they will re-declare their bindings in each Kodein instance you use.
      If you create a module that defines a singleton and import that module into two different Kodein instances, then the singleton object will exist twice: once in each Kodein instance.


=== Extension (composition)

Kodein allows you to create a new Kodein instance by extending an existing one.

[source, kotlin]
.Example: extends an already existing Kodein instance
----
val subKodein = Kodein {
    extend(appKodein)
    /* other bindings */
}
----

NOTE: This *preserves bindings*, meaning that a singleton in the parent Kodein will continue to exist only once.
      Both parent and child Kodein objects will give the same instance.


=== Overriding

By default, overriding a binding is not allowed in Kodein.
That is because accidentally binding twice the same (class,tag) to different instances/providers/factories can cause real headaches to debug.

However, when intended, it can be really interesting to override a binding, especially when creating a testing environment.
You can override an existing binding by specifying explicitly that it is an override.

[source, kotlin]
.Example: binds twice the same type, the second time explitly specifying an override
----
val kodein = Kodein {
    bind<API>() with singleton { APIImpl() }
    /* ... */
    bind<API>(overrides = true) with singleton { OtherAPIImpl() }
}
----

By default, *modules are not allowed to override, _even explicitly_*.
You can allow a module to override some of your bindings when you import it (the same goes for extension):

[source, kotlin]
.Example: imports a module and giving it the right to override existing bindings.
----
val kodein = Kodein {
    /* ... */
    import(testEnvModule, allowOverride = true)
}
----

WARNING: The bindings in the module still need to specify explicitly the overrides.

Sometimes, you just want to define bindings without knowing if you are actually overriding a previous binding or defining a new.
Those cases should be rare and you should know what you are doing.

[source, kotlin]
.Example: declaring a module in which each binding may or may not override existing bindings.
----
val testModule = Kodein.Module(allowSilentOverride = true) {
    bind<EmailClient>() with singleton { MockEmailClient() } <1>
}
----
<1> Maybe adding a new binding, maybe overriding an existing one, who knows?

If you want to access an instance retrieved by the overridden binding, you can use overriddenInstance.
This is useful if you want to "enhance" a binding (for example, using the decorator pattern).

[source, kotlin]
.Example: declaring a module in which each binding may or may not override existing bindings.
----
val testModule = Kodein.Module {
    bind<Logger>(overrides = true) with singleton { FileLoggerWrapper("path/to/file", overriddenInstance()) } <1>
}
----
<1> `overriddenInstance()` will return the `Logger` instance retrieved by the overridden binding.


== Dependency retrieval

[source, kotlin]
.Example bindings that are used throughout the chapter:
----
val kodein = Kodein {
    bind<Dice>() with factory { sides: Int -> RandomDice(sides) }
    bind<DataSource>() with singleton { SqliteDS.open("path/to/file") }
    bind<Random>() with provider { SecureRandom() }
    constant("answer") with "fourty-two"
}
----


=== Retrieval rules

.When retrieving a dependency, the following rules apply:
* A dependency bound with a `factory`, a `scopedSingleton` or a `multiton` can only be retrieved as a factory method: `(A) -> T`.
* A dependency bound with a `provider`, an `instance`, a `singleton`, an `eagerSingleton`, a `refSingleton`, an `autoScopedSingleton` or a `constant` can be retrieved:
** as a provider method: `() -> T`
** as an instance: `T`


=== Via Kodein methods

==== Standard retrieval

You can retrieve a dependency via a Kodein instance.

[source, kotlin]
.Example: retrieving bindings
----
val diceFactory: (Int) -> Dice = kodein.factory()
val dataSource: DataSource = kodein.instance()
val randomProvider: () -> Random = kodein.provider()
val answerConstant: String = kodein.instance("answer")
----

NOTE: When using a provider function (`() -> T`), whether this function will give each time a new instance or the same depends on the binding.

WARNING: When asking for a type that was not bound, a `Kodein.NotFoundException` will be thrown.

If you are not sure (or simply do not know) if the type has been bound, you can use `*OrNull` methods.

[source, kotlin]
.Example: retrieving bindings that may not have been bound
----
val diceFactory: ((Int) -> Dice)? = kodein.factoryOrNull()
val dataSource: DataSource? = kodein.instanceOrNull()
val randomProvider: (() -> Random)? = kodein.providerOrNull()
val answerConstant: String? = kodein.instanceOrNull("answer")
----

==== Currying factories

You can retrieve a provider or an instance from a factory bound type by using `with` (this is called _currying_).

[source, kotlin]
.Example: currying factories
----
private val sixSideDiceProvider: () -> Dice = kodein.with(6).provider()
private val sixSideDice: Dice = kodein.with(6).instance()
----

==== Creating new instances

You can easily create a new instance of an unbound class with the same syntax as if you bound it:

.Example: creating a new unbound instance
----
private val sql1 = kodein.newInstance { SQLiteConnection(instance()) } <1>
private val sql2 = kodein.newInstance { SQLiteConnection(instance("path")) } <2>
----
<1> Passing a transitive dependency.
<2> Passing a transitive dependency bound with a tag.

[[kodein-aware]]
==== Being Kodein aware

You can have classes that implement the interface `KodeinAware`. +
Doing so has the benefit of getting a simpler syntax for retrieval.

[source, kotlin]
.Example: a KodeinAware class
----
class MyManager(override val kodein: Kodein) : KodeinAware {
    val datasource: DataSource = instance()
    val random: Random = instance()
    val diceFactory: (Int) -> Dice = factory()
    val d6: Dice = with(6).instance()
}
----

All methods that are available to `Kodein` are available to a `KodeinAware` class.


=== Via lazy properties

Lazy properties allow you to resolve the dependency upon first access using kotlin's https://kotlinlang.org/docs/reference/delegated-properties.html[delegated properties].

[source, kotlin]
.Example: retrieving lazy properties
----
class Controller(private val kodein: Kodein) {
    private val diceFactory: (Int) -> Dice by kodein.lazy.factory() <1>
    private val dataSource: DataSource by kodein.lazy.instance() <1>
    private val randomProvider: () -> Random by kodein.lazy.provider() <1>
    private val answerConstant: String by kodein.lazy.instance("answer") <1>
}
----
<1> Note the use of `by` instead of `=`.

`kodein.lazy.factoryOrNull`, `kodein.lazy.providerOrNull` and `kodein.lazy.instanceOrNull` are also available.

You can curry factories and retrieve a lazy property with the same `lazy` access.

[source, kotlin]
.Example: retrieving lazy curried factory properties
----
private val sixSideDiceProvider: () -> Dice by kodein.with(6).lazy.provider()
private val sixSideDice: Dice by kodein.with(6).lazy.instance()
----

If you don't know yet the parameter to curry the factory with, you can pass a lambda.
That way, the parameter will be fetched only when needed.

[source, kotlin]
.Example: retrieving lazy curried factory properties with lazy parameters
----
private val randomSideDiceProvider: () -> Dice
        by kodein.with { random.nextInt(20) + 1 }.lazy.provider()
----


[[injector]]
=== Via an injector

==== On an injector object

An injector is an object that you can use to inject all dependency properties in an object.

.This allows your object to:
* Retrieve all its injected dependencies at once;
* Declare its dependencies without a Kodein instance.

[source, kotlin]
.Example: retrieving properties via an injector
----
class Controller() {
    private val injector = KodeinInjector() // <1>

    private val diceFactory: (Int) -> Dice by injector.factory() // <2>
    private val dataSource: DataSource by injector.instance() // <2>
    private val randomProvider: () -> Random by injector.provider() // <2>
    private val answerConstant: String by injector.instance("answer") // <2>

    private val kodein by injector.kodein() // <3>

    fun whenReady(kodein: Kodein) = injector.inject(kodein) // <4>
}
----
<1> Creating an injector
<2> Creating lazy properties.
<3> Creating a lazy Kodein that will be available after injection.
<4> Injecting all properties created by the injector.

WARNING: If you try to access a property created by an injector *before* calling `injector.inject(kodein)`, a `KodeinInjector.UninjectedException` will be thrown.

`injector.factoryOrNull`, `injector.providerOrNull` and `injector.instanceOrNull` are also available.

As usual, you can curry factories by using `with`.

[source, kotlin]
.Example: creating curried factory properties
----
private val sixSideDiceProvider: () -> Dice by injector.with(6).provider()
private val tenSideDiceProvider: Dice by injector.with(10).instance()
----

[[kodein-injected]]
==== In a Kodein injected class

You can have classes that implement the interface `KodeinInjected`.
Doing so has the benefit of getting a simpler syntax for injection.

[source, kotlin]
.Example: a KodeinInjected class
----
class MyManager() : KodeinInjected {
    override val injector = KodeinInjector()

    val ds: DataSource by instance()
}
----

All methods that are available to `KodeinInjector` are available to a `KodeinInjected` class.


=== Via a lazy Kodein

==== On a LazyKodein object

Sometimes, you don't directly have access to a Kodein instance but you know how to get one later.
In these cases, if you don't want to use an <<injector,injector>>, you can use `LazyKodein`.

[source, kotlin]
.Example: retrieving properties via an injector
----
class Controller() {
    private val kodein = LazyKodein { /* code to access a Kodein instance */ } // <1>

    private val diceFactory: (Int) -> Dice by kodein.factory() // <2>
    private val answerConstant: String by kodein.instance("answer") // <2>

    fun someFunction() {
        val dataSource: DataSource = kodein().instance() <3>
    }
}
----
<1> Note the usage of `=` and not `by`.
<2> Creating lazy properties (I am using a `LazyKodein`, not `Kodein` instance).
<3> To access a `Kodein` instance, I use `kodein()`.

You can create a LazyKodein with `Kodein.lazy`.
When doing so, even the bindings will be declared only when the first retrieval happens.

[source, kotlin]
.Example: using Kodein.lazy
----
val kodein = Kodein.lazy { // <1>
    println("doing bindings")
    bind<DataSource>() with singleton { SqliteDS.open("path/to/file") }
}

class Controller() {
    val ds: DataSource by kodein.instance()

    fun someFunction() {
        ds.open() // <2>
    }
}
----
<1> The `kodein` object is of type `LazyKodein`, not `Kodein`.
<2> Only there will "doing bindings" will be printed.

[[lazy-kodein-aware]]
==== In a lazy Kodein aware class

You can have classes that implement the interface `LazyKodeinAware`.
Doing so has the benefit of getting a simpler syntax for lazy property creation.

[source, kotlin]
.Example: a LazykodeinAware class
----
class MyManager() : LazyKodeinAware {
    override val kodein = LazyKodein { /* code to access a Kodein instance */ }

    val ds: DataSource by instance()
}
----

All methods that are available to `LazyKodein` are available to a `LazyKodeinAware` class.


=== Class factories (such as loggers)

Sometimes you need to retrieve objects that are dependent to the class of the object whose retrieval is for. +
The most obvious example is loggers: you need loggers that will print the name of the class name of _the class they are in_.

First, you need to declare a binding to a factory that takes a `Class` as argument.

[source, kotlin]
.Example: binding a logger
----
val kodein = Kodein {
    bind<Logger>() with multiton { cls: Class<*> -> LogManager.getLogger(cls) }
}
----

Then, you can retrieve such bound types by using `withClassOf`.

[source, kotlin]
.Example: retrieving a logger
----
class MyManager(val kodein: Kodein) {
    val logger: Logger = kodein.withClassOf(this).instance()
}
----

If you are using a <<kodein-aware,Kodein aware class>>, a <<kodein-injected,Kodein injected class>> or a <<lazy-kodein-aware,lazy Kodein aware class>>, then it's even easier: simply use `withClass`.

[source, kotlin]
.Example: retrieving a logger in a KodeinAware class
----
class MyManager(override val kodein: Kodein): KodeinAware {
    val logger: Logger = withClass().instance()
}
----

NOTE: You can use `withClass` for factories that take a `Class<*>` as parameter, and `withKClass` for factories that take a `KClass<*>` as parameter.


=== In Java

While Kodein does not allow you to declare modules or dependencies in Java, it does allow you to retrieve dependencies.
Simply give the Kodein instance to your Java classes, use Kodein in Java with the `TT` static function:

[source, java]
.Example: using Kodein in Java
----
import static com.github.salomonbrys.kodein.TypesKt.TT;

public class JavaClass {
    private final Function1<Integer, Dice> diceFactory;
    private final Datasource dataSource;
    private final Function0<Random> randomProvider;
    private final String answerConstant;

    public JavaClass(Kodein kodein) {
        diceFactory = kodein.Factory(TT(Integer.class), TT(Dice.class), null);
        dataSource = kodein.Instance(TT(Datasource.class), null);
        randomProvider = kodein.Provider(TT(Random.class), null);
        answerConstant = kodein.Instance(TT(String.class), "answer");
    }}
----

[WARNING]
====
Remember that Java is subject to type erasure.
Therefore, if you registered a generic Class binding such as `bind<List<String>>()`, in order to retrieve it you have to use `TypeReference` to circumvent Java's type erasure.

[source, java]
.Example: using TypeReference in Java
----
class JavaClass {
    private final List<String> list;

    public JavaClass(TKodein kodein) {
        list = kodein.Instance(TT(new TypeReference<List<String>>() {}), null);
    }
}
----
====


== Multi-binding

Kodein allows multi bindings via a binding set.


=== In a set

To have multiple bindings in a set, you need to:

* Declare that you are using a set binding for a particular bound type.
* Add bindings to the set.

[source,kotlin]
.Example creating a set of `Configuration` bindings.
----
val kodein = Kodein {
    bind() from setBinding<Configuration>() <1>

    bind<Configuration>().inSet() with provider { FooConfiguration() } <2>
    bind<Configuration>().inSet() with singleton { BarConfiguration() } <2>
}
----
<1> Creating a set binding of `Configuration`.
<2> Binding multiple `Configuration` implementations.

[NOTE]
====
You can:

* Use different binding types (such as `provider` or `singleton`) in the same set.
* Add bindings to the same set in different modules, provided that the set has been declared first.
====


=== Retrieve a set binding

Note that the type being bound is `Set<T>`, not `T`. +
Therefore, you need to retrieve a `Set`:

[source,kotlin]
.Example retrieving set of `Configuration`.
----
val configurations: Set<Configuration> = kodein.instance()
----


=== Using bindings with arguments

You can also bind multiple bindings with arguments (such as `factory` or `multiton`) in a set *as long as all bindings share the same argument type*.

[source,kotlin]
.Example creating a set of `Result` bindings.
----
val kodein = Kodein {
    bind() from argSetBinding<Query, Result>()

    bind<Result>().inSet() with factory { q: Query -> Foo.query(q) }
    bind<Result>().inSet() with multiton { q: Query -> Bar.query(q) }
}
----


=== In a map

Kodein does not support map multibinding directly.
However, it is very easy to create a binding map by using a binding set.

First, create the following primitive:

[source,kotlin]
.Example of the type alias for a map multibinding as `Map<String, Configuration>`.
----
typealias ConfigurationEntry = Pair<String, Configuration>
typealias ConfigurationEntries = Set<ConfigurationEntry>
----

Then, bind with keys:

[source,kotlin]
.Example binding as in a map multibinding.
----
val kodein = Kodein {
    bind() from setBinding<ConfigurationEntry>()

    bind<ConfigurationEntry>().inSet() with factory { "foo" to FooConfiguration() }
    bind<ConfigurationEntry>().inSet() with multiton { "bar" to BarConfiguration() }
}
----

Finally, retrieve the map:

[source,kotlin]
.Example retrieving a map multibinding.
----
val configurations = kodein.instance<ConfigurationEntries>().toMap()
----


=== Special considerations for erased environments

WARNING: This paragraph is addressed to <<javascript>> users or JVM users who chose to <<erased-by-default,use erased by default>>.
         Please read the corresponding sections before reading this.

As you may have notice, `Set` is a parameterized type, meaning that set binding cannot work as is.
To circumvent this, in erased environments, set bindings are bound using <<erased-comp,composite type tokens>>.

This means that you *cannot retrieve a set binding with `kodein.instance()`*.
You must retrieve a set binding with `kodein.Instance()` (note the uppercase) and provide the appropriate composite type token.

To make it easier, Kodein provides the `erasedSet` function:

[source,kotlin]
.Example retrieving a set multibinding in an erased environment.
----
val configurations: Set<Configuration> = kodein.Instance(erasedSet())
----


== Configuring on the go (Configurable Kodein)

Maybe you want a Kodein instance that you can pass around and have different sections of your code configure its bindings.

Configurable Kodein is a Kodein extension that is not proposed  _by default_, this paradigm is in a separate module.

NOTE: Using or not using this is a matter of taste and is neither recommended nor discouraged.

[source,kotlin]
.Example creating, configuring and using a `ConfigurableKodein`.
----
fun addSomeConf(kodein: Kodein) {
    kodein.addModule(apiModule)
    kodein.addModule(dbModule)
}

fun test() {
    val kodein = ConfigurableKodein()
    kodein.addModule(appModule)

    addSomeConf(kodein)

    val ds: DataSource = kodein.instance()
}
----


=== Install

==== With Maven

[source,xml,subs="attributes"]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.github.salomonbrys.kodein&lt;/groupId&gt;
    &lt;artifactId&gt;kodein-conf&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;
----

IMPORTANT: Do not remove the `kodein` (or `kodein-erased`) dependency.
           Both dependencies must be declared.

==== With Gradle

[source,groovy,subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein-conf:{version}'
----

IMPORTANT: Do not remove the `kodein` (or `kodein-erased`) dependency.
           Both dependencies must be declared.


=== Configuring

You can import modules, extend kodein objects, or add bindings inside this `ConfigurableKodein` using `addImport`, `addExtend` and `addConfig`.

[source, kotlin]
.Example: adding a module inside the global Kodein
----
fun test() {
    val kodein = ConfigurableKodein()

    kodein.addModule(aModule)
    kodein.addExtend(otherKodein)

    kodein.addConfig {
        bind<Dice>() with provider { RandomDice(0, 5) }
        bind<DataSource>() with singleton { SqliteDS.open("path/to/file") }
    }
}
----

CAUTION: The Kodein object will effectively be constructed on first retrieval.
         Once it is constructed, trying to configure it will throw an `IllegalStateException`.


=== Retrieving

You can use a `ConfigurableKodein` object like any `Kodein` object.

CAUTION: Once you have retrieved the first value with a `ConfigurableKodein`, trying to configure it will throw an `IllegalStateException`.


=== Mutating

A `ConfigurableKodein` can be mutable.

[source, kotlin]
.Example: Creating a mutable ConfigurableKodein
----
val kodein = ConfigurableKodein(mutable = true)
----

[WARNING]
====
Using a mutable `ConfigurableKodein` can lead to *very bad code practice* and *very difficult bugs*. +
Therefore, using a mutable `ConfigurableKodein` *IS discouraged*. +
Note that every time a `ConfigurableKodein` is mutated, its cache is entirely flushed, meaning that it has a real impact on optimization! +
Please use the mutating feature only if you truly need it, know what you're doing, and see no other way.
====

A mutable `ConfigurableKodein` can be configured even _after first retrieval_.

[source, kotlin]
.Example: mutating a mutable ConfigurableKodein
----
fun test() {
    val kodein = ConfigurableKodein(mutable = true)

    kodein.addModule(aModule)

    val ds: DataSource = kodein.instance()

    kodein.addModule(anotherModule) <1>
}
----
<1> This would have failed if the ConfigurableKodein was not mutable.

You can also use `clear` to remove all bindings.


=== The god complex: One True Kodein

Sometimes, you want one static Kodein for your entire application.
E.g. you don't want to have to hold & pass a Kodein instance throughout your application.

For these cases, the `kodein-conf` module proposes a static `Kodein.global` instance.

[source,kotlin]
.Example creating, configuring and using the global one true Kodein.
----
fun test() {
    kodein.global.addModule(apiModule)
    kodein.global.addModule(dbModule)

    val ds: DataSource = kodein.global.instance()
}
----

[CAUTION]
====
Just like any `ConfigurableKodein`, `Kodein.global` must be configured *before* being used for retrieval, or an `IllegalStateException` will be thrown.
It is possible to set `Kodein.global` to be mutable by setting `Kodein.global.mutable = true` but it *must* be set *before* any retrieval!
====


=== Being globally aware

You can use the `GlobalKodeinAware` interface that needs no implementation to be aware of the global kodein.

[source, kotlin]
.Example: a KodeinGlobalAware class
----
class MyManager() : KodeinGlobalAware {
    val ds: DataSource = instance()
}
----


== Android

[.lead]
Kodein does work on Android!

You can use Kodein as-is in your Android project or use the util library `kodein-android`.

NOTE: Kodein does work on Android as-is.
      The `kodein-android` extension adds multiple android-specific utilities to Kodein. +
      Using or not using this extension really depends on your needs.

Have a look at the https://github.com/SalomonBrys/Kodein/tree/{branch}/demo-android[Android demo project]!


=== Install

.How to use `kodein-android`:
. Add this line in your `dependencies` block in your application `build.gradle` file:
+
[subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein:{version}'
compile 'com.github.salomonbrys.kodein:kodein-android:{version}'
----
+
IMPORTANT: Both `kodein` and `kodein-android` dependencies must be declared. +
+
WARNING: If you are using `kodein-erased`, then you must declare both dependencies : `kodein-erased` and `kodein-android` (but not `kodein`).

. If you are using Proguard, you need to add the following line to your proguard configuration file:
+
----
-keepattributes Signature
----

. Declare the dependency bindings in the Android `Application`, having it implements `KodeinAware`.
+
[source, kotlin]
.Example: an Android Application class that implements KodeinAware
----
class MyApp : Application(), KodeinAware {
	override val kodein by Kodein.lazy { <1>
	    /* bindings */
	}
}
----
<1> Using Kodein.lazy allows you to access the `Context` at binding time.
+
TIP: Don't forget to declare the Application in the `AndroidManifest.xml` file!

. In your Activities, Fragments, and other context aware android classes, retrieve dependencies!


=== Bindings & retrieval

==== Using a LazyKodein

`appKodein` is a property that will work in your context aware Android classes provided that your Application implements `KodeinAware`.
From it, you can construct a `LazyKodein`.

[source, kotlin]
.Example: retrieving dependencies with LazyKodein in Android
----
class MyActivity : Activity() {
    val kodein = LazyKodein(appKodein)

    val diceProvider: () -> Dice by kodein.provider() // <1>

    override fun onCreate(savedInstanceState: Bundle?) {
        val random: Random = kodein().instance()   // <2>
    }
}
----
<1> `kodein` without parenthesis: creates a lazy property.
<2> `kodein` with parenthesis: gets the instance.

WARNING: You cannot use `kodein` with parenthesis and access the Kodein instance while the activity is not initialized by Android.

==== Using an injector

Using an injector allows you to resolve all dependencies in `onCreate`, reducing the cost of dependency first-access (but more processing happening in `onCreate`).

[source, kotlin]
.Example: retrieving dependencies with an injector in Android
----
class MyActivity : Activity() {
    private val injector = KodeinInjector()

    val random: Random by injector.instance()

    override fun onCreate(savedInstanceState: Bundle?) {
        injector.inject(appKodein())
    }
}
----

NOTE: Using this approach has an important advantage: as all dependencies are retrieved in `onCreate`, you can be sure that all your dependencies have correctly been retrieved, meaning that there were no non-declared dependency. +
      If you only use `instance` (no `provider` or `factory`), you can also be sure that there were no dependency loop.

==== Being aware in Android

`appKodein` cannot be accessed before an activity has been created, before a fragment has been attached, and so on.
Because of this, it is not recommended to use `KodeinAware` in Android.
Prefer using `LazyKodeinAware` or `KodeinInjected`.

[source, kotlin]
.Example: retrieving dependencies with LazyKodeinAware in Android
----
class MyActivity : Activity(), LazyKodeinAware {
    override val kodein = LazyKodein(appKodein)

    val diceProvider: () -> Dice by provider()
}
----

[source, kotlin]
.Example: retrieving dependencies with KodeinInjected in Android
----
class MyActivity : Activity(), KodeinInjected {
    override val injector = KodeinInjector()

    val random: Random by instance()

    override fun onCreate(savedInstanceState: Bundle?) {
        inject(appKodein())
    }
}
----


=== Bootstrapping Kodein on Android

To easily setup Kodein with your Android app, you can use the Android Injectors. They make it simple to creating activities, fragments, services, and broadcast recivers that work with Kodein out of the box.

NOTE: This method allows for deep Kodein integration into you Android components.
      You can choose to use Kodein without it.

There are two ways to use them depending on your needs; inheritance based and interface based.

Both methods provide you with:

* A `KodeinInjector` (through the `injector` property)
* A binding for `KodeinInjected` (which is the instance of your class)
* Local bindings (bindings for that specific instance)
** One example is a `KodeinActivity` or `ActivityInjector` will bind `Context` and `Activity` to itself, and `FragmentManager`, `LoaderManager`, and `LayoutInflater` to its instances of those classes.
* Scope management (removing this component from the scope when it is destroyed so there are no memory leaks)
* The ability to override previously defined bindings

IMPORTANT: Don't forget to use an `Application` that is `KodeinAware`:

==== Inheritance Based

Kodein provides base classes for the following Android components:

* Activity (`KodeinActivity`)
* FragmentActivity (`KodeinFragmentActivity`)
* AppCompatActivity (`KodeinAppCompatActivity`)
* Fragment (`KodeinFragment`)
* Support v4 Fragment (`KodeinSupportFragment`)
* Service (`KodeinService`)
* IntentService (`KodeinIntentService`)
* BroadcastReceiver (`KodeinBroadcastReceiver`)

All it takes to get started is to extend one of those classes, and you're ready to start injecting. Let's see an example.

[source, kotlin]
.Example: using KodeinActivity to make injecting easier
----
class MyActivity : KodeinActivity() { // <1>
    private val logTag: String by instance("log-tag") // <2>
    private val app: Application by injector.instance() // <3>

    override fun provideOverridingModule() = Kodein.Module { // <4>
        bind<MyActivity>() with instance(this@MyActivity)
        bind<String>("log-tag", overrides = true) with instance("MyActivity")
    }

    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate(savedInstanceState)

        Log.i(logTag, "Calling onCreate from MainActivity in ${app.applicationInfo.className}")
    }
}
----
<1> Extending `KodeinActivity` provides us with a `KodeinInjector` and takes care of its lifecycle
<2> `KodeinActivity` implements `KodeinInjected` so we don't need to use the `injector` property if we don't want to
<3> We can also use the `injector` if we want to
<4> `provideOverridingModule` allows us to override bindings specified higher up in the dependency tree (for example, we override the "log-tag" `String` binding defined in `MyApplication`)

CAUTION: `KodeinActivity`, `KodeinFragmentActivity`, and `KodeinAppCompatActivity` will internally initialize their injector before they call `super.onCreate` (see https://github.com/SalomonBrys/Kodein/issues/50[the issue that necessitates this]).

===== KodeinBroadcastReceiver

Because of how the injector's lifecycle is managed for a `KodeinBroadcastReceiver`, subclasses should override `onBroadcastReceived(Context, Intent)` instead of `onReceive(Context, Intent)`.

==== Interface Based

Kodein also provides a set of interfaces that provide the same functionality as the inheritance based method.
The only difference is that the injector lifecycle must be managed.
In almost every case, this can be accomplished by simply calling `initializeInjector` immediately after `onCreate` and `destroyInjector` immediately before `onDestroy`.

These are provided so that you can extend non-framework components if needed, because the JVM does not support multiple class inheritance.

The interfaces are:

* ActivityInjector
* FragmentActivityInjector
* AppCompatActivityInjector
* FragmentInjector
* SupportFragmentInjector
* ServiceInjector
* IntentServiceInjector
* BroadcastReceiverInjector

[source, kotlin]
.Example: using FragmentInjector to make injecting easier
----
class MyFragment : CustomFragment(), FragmentInjector { // <1>
    override val injector: KodeinInjector = KodeinInjector() // <2>

    private val logTag: String by instance("log-tag") // <3>
    private val app: Application by injector.instance() // <4>

    override fun provideOverridingModule() = Kodein.Module { // <5>
        bind<MyFragment>() with instance(this@MyFragment)
        bind<String>("log-tag", overrides = true) with instance("MyFragment")
    }

    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate(savedInstanceState)

        initializeInjector() // <6>

        Log.i(logTag, "Calling onCreate from MainActivity in ${app.applicationInfo.className}")
    }

    override fun onDestroy() {
        destroyInjector() // <7>
        super.onDestroy()
    }
}
----
<1> Because we extends `CustomFragment` we cannot extend `KodeinFragment` so instead we implement `FragmentInjector`
<2> We have to provide an injector (typically all that entails is just creating a new instance of `KodeinInjector`)
<3> `FragmentInjector` implements `KodeinInjected` so we don't need to use the `injector` property if we don't want to
<4> We can also use the `injector` if we want to
<5> `provideOverridingModule` allows us to override bindings specified higher up in the dependency tree (for example, we override the "log-tag" `String` binding defined in `MyApplication`)
<6> Since we have to manage the injector's lifecycle we initialize it when the fragment is initialized; in `onCreate`
<7> Since we have to manage the injector's lifecycle we destroy it when the fragment is destroyed in `onDestroy`

CAUTION: When using `ActivityInjector`, `FragmentActivityInjector`, or `AppCompatActivityInjector` it is suggested to call `initializeInjector` before `super.onCreate` (see https://github.com/SalomonBrys/Kodein/issues/50[the issue that necessitates this]).

===== BroadcastReceiverInjector

`BroadcastReceiverInjector` should be used like this:

[source, kotlin]
.Example: implementing BroadcastReceiverInjector
----
class MyBroadcastReceiver : CustomBroadcastReceiver(), BroadcastReceiverInjector {
    override val injector: KodeinInjector = KodeinInjector()

    final override var context: Context? = null

    final override fun onReceive(context: Context, intent: Intent) {
      super.onReceive(context, intent)

      this.context = context <1>
      initializeInjector()
      // do something
      destroyInjector()
    }
}
----
<1> It is necessary to set `BroadcastReceiverInjector.context` before calling `initializeInjector`

==== Fragments

The parent of any `KodeinFragment`, `KodeinSupportFragment`, `FragmentInjector`, or `SupportFragmentInjector` **must** be `KodeinInjected`.
This means a `parentFragment` **must** be one of `KodeinFragment`, `KodeinSupportFragment`, `FragmentInjector`, or `SupportFragmentInjector`.
If there is no `parentFragment`, the `Activity` of the `Fragment` **must** be one of `KodeinActivity`, `KodeinFragmentActivity`, `KodeinAppCompatActivity`, `ActivityInjector`, `FragmentActivityInjector`, or `AppCompatActivityInjector`.

NOTE: Inside a fragment, you can retrive a `LayoutInflater` using the tag `ACTIVITY_LAYOUT_INFLATER`.
      Using the tag will use a more optimized way of retrieving the `LayoutInflater`.

=== Android module

Kodein-Android proposes a module that enables easy retrieval, with a context, of a lot of standard android services.

This module is absolutely *optional*, you are free to use it or leave it ;).

[source, kotlin]
.Example: importing the android module
----
val kodein = Kodein {
    import(androidModule)
    /* other bindings */
}
----

You can see everything that this module proposes in the https://github.com/SalomonBrys/Kodein/blob/{branch}/kodein-android/src/main/java/com/github/salomonbrys/kodein/android/AndroidModule.kt[AndroidModule.kt] file.

To retrieve instances of bindings defined in this module, you can use `withContext`.

[source, kotlin]
.Example: using kodein to retrieve a LayoutInflater
----
class MyActivity : Activity(), LazyKodeinAware {
    override val kodein = LazyKodein(appKodein)

    val inflater: LayoutInflater by withContext(this).instance()
}
----

There is also an "auto" version of the module.

[source, kotlin]
.Example: importing the android module
----
class MyApplication : Application(), KodeinAware {
  override val kodein by Kodein.lazy {
    import(autoAndroidModule(this@MyApplication))
    /* other bindings */
  }
}
----

Retrieving instances of bindings from the autoAndroidModule does not require a `Context`.

[source, kotlin]
.Example: using kodein to retrieve a LayoutInflater
----
class MyActivity : Activity(), LazyKodeinAware {
    override val kodein = LazyKodein(appKodein)

    val inflater: LayoutInflater by instance()
}
----

You can see everything that this module proposes in the https://github.com/SalomonBrys/Kodein/blob/{branch}/kodein-android/src/main/java/com/github/salomonbrys/kodein/android/AndroidModule.kt[AndroidModule.kt] file.


=== Android scopes

==== The context scope

There are times where you need an object to be a singleton, but only during the lifetime of a `Context`.
You can use the `contextSingleton` scope to achieve this.

NOTE: The context scope should be used when a binding could apply to either an `Activity` or a `Service`.
      When a binding is exclusively for an `Activity` or a `Service`, the <<activity-scope,activity>> or <<service-scope,service>> scope should be used instead.

[source, kotlin]
.Example: using the context scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidContextScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the context the object is being created for.

To retrieve an object bound in the context scope, you need to inject a factory that takes the context as a parameter.

[source, kotlin]
.Example: retrieving a context scoped singleton
----
val logger: Logger = kodein.with(context).instance()
val sameLogger: Logger = kodein.with(context).instance() // this will be the same object as logger
val otherLogger: Logger = kodein.with(otherContext).instance() // this will be a different object than logger
----

NOTE: The activity and service scope are special cases of the context scope.
      The bindings returned for an `Activity` or `Service` object from the context scope will be the same one returned for that object from the activity or service scope.

[[activity-scope]]
==== The activity scope

If you want a singleton that lives only during the lifecycle of a specific `Activity`, and not any `Context`, you can use the activity scope.

[source, kotlin]
.Example: using the activity scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidActivityScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the activity the object is being created for.

As with the context scope, to retrieve objects bound in the activity scope, you need to inject a factory which takes the activity as a parameter.

[source, kotlin]
.Example: retrieving an activity scoped singleton
----
val logger: Logger = kodein.with(getActivity()).instance()
----

==== The auto activity scope

If you don't want to be required to explicitly provide an activity instance to inject your objects, you can use the "auto activity scope".

[source, kotlin]
.Example: using the auto activity scope
----
val kodein = Kodein {
    bind<Logger>() with autoScopedSingleton(androidActivityScope) { LogManager.getNamedLogger(it.localClassName) }
}
----

[source, kotlin]
.Example: retrieving an auto activity scoped singleton
----
val logger: Logger = kodein.instance()
----

However, for Kodein to know which activity is the current one, you *must* add this line in your `Application` class in the `onCreate` method:

[source, kotlin]
.Example: registering kodein's lifecycle manager to enable the auto activity scope to work
----
class MyApplication : Application {
    override fun onCreate() {
        registerActivityLifecycleCallbacks(
                androidActivityScope.lifecycleManager // <1>
        )
    }
}
----
<1> `androidActivityScope.lifecycleManager` is what enables the auto scope to work.

CAUTION: Objects that are bound in the auto `androidActivityScope` will always be injected according to *the last displayed activity*.

[[service-scope]]
==== The service scope

If you want a singleton that lives only during the lifecycle of a specific `Service`, and not any `Context`, you can use the service scope.

[source, kotlin]
.Example: using the service scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidServiceScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the service the object is being created for.

As with the context scope, to retrieve objects bound in the service scope, you need to inject a factory which takes the service as a parameter.

[source, kotlin]
.Example: retrieving a service scoped singleton
----
val logger: Logger = kodein.with(service).instance()
----

==== The fragment (and support fragment) scope

If you want a singleton that lives only during the lifecycle of a specific `Fragment`, you can use the fragment scope (or support fragment scope if you are using support lib fragments).

[source, kotlin]
.Example: using the fragment scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidFragmentScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the fragment the object is being created for.

[source, kotlin]
.Example: using the support fragment scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidSupportFragmentScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the support fragment the object is being created for.

To retrieve objects bound in the fragment scope (or support fragment scope), you need to inject a factory which takes the fragment as a parameter.

[source, kotlin]
.Example: retrieving a fragment scoped singleton
----
val logger: Logger = kodein.with(fragment).instance()
----

[source, kotlin]
.Example: retrieving a support fragment scoped singleton
----
val logger: Logger = kodein.with(supportFragment).instance()
----

==== The broadcast receiver scope

If you want a singleton that lives only during the lifecycle of a specific `BroadcastReceiver`, you can use the broadcast receiver scope.

[source, kotlin]
.Example: using the broadcast receiver scope
----
val kodein = Kodein {
    bind<Logger>() with scopedSingleton(androidBroadcastReceiverScope) { LogManager.getNamedLogger(it.localClassName) } // <1>
}
----
<1> `it` is the broadcast receiver the object is being created for.

To retrieve objects bound in the broadcast receiver scope, you need to inject a factory which takes the broadcast receiver as a parameter.

[source, kotlin]
.Example: retrieving a broadcast receiver scoped singleton
----
val logger: Logger = kodein.with(broadcastReceiver).instance()
----


[[javascript]]
== JavaScript

[.lead]
Kodein does work on JavaScript!

However, there a few limitations that are due to the fact that reflection is severely limited in JS.

Kodein for JavaScript is compiled as a https://github.com/umdjs/umd[UMD module] so that it can be used both in a browser or in a NodeJS backend.

Have a look at the https://github.com/SalomonBrys/Kodein/tree/{branch}/js-demo[JavaScript demo project]!


=== Install

==== With Maven

[source,xml,subs="attributes"]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.github.salomonbrys.kodein&lt;/groupId&gt;
    &lt;artifactId&gt;kodein-js&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;
----

==== With Gradle

[source,groovy,subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein-js:{version}'
----


=== Usage

Because Kodein for JavaScript is compiled as a https://github.com/umdjs/umd[UMD module], it can be imported:

* In a browser:
** as an AMD module (for example with RequireJS) (See index.html in the demo project).
** Directly in an HTML page with a `<script>` tag (See index2.html in the demo project).
* In NodeJS, as a regular CJS module.

Once imported, Kodein is used without any other difference than those described in <<limitations>>.


[[limitations]]
=== Limitations

==== Type erasure

Kodein-JS functions are defined in the `com.salomonbrys.kodein.erased` package.
This is because *JS bindings are subject to type erasure*. +
Kotlin does not provide, at this moment, a way to circumvent type erasure on JS.

This means that you cannot bind `List<String>` and `List<User>` as both will effectively be bound as `List`.
(At least one of them needs to be bound with a tag).

NOTE: Because of the package difference, shared JVM / JS code need to either use `kodein-erased` or the uppercase functions.
Read <<jvm-performance>> to learn more.

==== Factory parameter super type inference

On the JVM, when you bind a factory with a non primitive argument, it is possible to retrieve the factory by providing a subtype of this argument. +
However, Kotlin JS does not support hierarchy introspection.
Therefore, this will work in the JVM but not in JS:

[source, kotlin]
.Example: binding a factory and retrieving it with an argument's subtype.
----
val kodein = Kodein {
    bind<Connection> with factory { ds: DataSource -> DBImpl(ds) }
}
val sqlDS: SQLiteDataSource = getSQLiteDS()
val con: Connection = kodein.with(sqlDS).instance() <1>
----
<1> Because `sqlDS` is of type `SQLiteDataSource` and not `DataSource`, this will succeed in the JVM but fail in JS.

To have the retrieval working in JS, you need to pass an argument of the exact type, which you can have by _casting_:

[source, kotlin]
.Example: retrieving a factory with the exact argument type.
----
val con: Connection = kodein.with(sqlDS as DataSource).instance() <1>
----
<1> By casting, we are implicitely passing the exact argument type.

This limitation of Kotlin JS is https://kotlinlang.org/docs/reference/js-reflection.html[documented].


=== JS Configurable Kodein

The `ConfigurableKodein` extension is available for JS, without any difference from the JVM version.

==== With Maven

[source,xml,subs="attributes"]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.github.salomonbrys.kodein&lt;/groupId&gt;
    &lt;artifactId&gt;kodein-js-conf&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;
----

==== With Gradle

[source,groovy,subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein-js-conf:{version}'
----


== Debugging

=== Print bindings

You can easily print bindings with `println(kodein.container.bindings.description)`.

Here's an example of what this prints:

.An example of kodein.container.bindings.description:
----
        bind<Dice>() with factory { Int -> RandomDice }
        bind<DataSource>() with singleton { SQLiteDataSource }
        bind<Random>() with provider { SecureRandom }
        bind<String>("answer") with instance ( Int )
----

As you can see, it's really easy to understand which type with which tag is bound to which implementation inside which scope.

NOTE: Descriptions prints type names in a "kotlin-esque" way.
      Because Kodein does not depends on `kotlin-reflect`, it uses java `Type` objects that do not contains nullability information.
      As such, the type display does not include nullability. Still, it's easier to read `List<*>` than `List<? extends Object>`.


=== Recursive dependency loop

When it detects a recursive dependency, Kodein will throw a `Kodein.DependencyLoopException`.
The message of the exception explains how the loop happened.

.An example of recursive dependency loop:
----
com.github.salomonbrys.kodein.Kodein$DependencyLoopException: Dependency recursion:
       > bind<com.test.A>()
       > bind<com.test.B>() // <1>
       > bind<com.test.C>("yay") // <2>
       > bind<com.test.A>() // <3>
----
<1> `com.test.A` depends on `com.test.B`
<2> `com.test.B` depends on `com.test.C` with the tag "Yay"
<3> `com.test.C` with the tag "Yay" depends on `com.test.A`, *we have found the dependency loop!*.


== JSR-330: Using reflexivity to auto-inject

Kodein offers a module that implements reflexivity injection based on the JSR-330 `javax.inject.*` annotations.
There are two reasons to use this module:

- You are moving a code base from a Java injection library (such as Guice or Dagger) and want the Java code to work the same while there still is injected java code.
- You want to easilly use Kodein in a Java code.
- That's it!

Using this module with Kotlin code means adding a lot of reflexivity at run-time that can easily be avoided in Kotlin (but not in Java).

CAUTION: Every-thing that is described here is *a lot less performant* than using classic Kodein injection methods.
         PLEASE DO NOT USE ON KOTLIN CLASSES.
         Kittens *will* die painfully if you do!


[jxinject-install]
=== Install

==== With Maven

[source,xml,subs="attributes"]
----
&lt;dependency&gt;
    &lt;groupId&gt;com.github.salomonbrys.kodein&lt;/groupId&gt;
    &lt;artifactId&gt;kodein-jxinject&lt;/artifactId&gt;
    &lt;version&gt;{version}&lt;/version&gt;
&lt;/dependency&gt;
----

IMPORTANT: Do not remove the "kodein" (or "kodein-erased") dependency.
           Both dependencies must be declared.

Then, <<import-jxinject-module,import the module>>.

==== With Gradle

[source,groovy,subs="attributes"]
----
compile 'com.github.salomonbrys.kodein:kodein-jxinject:{version}'
----

IMPORTANT: Do not remove the "kodein" (or "kodein-erased") dependency.
           Both dependencies must be declared.

Then, <<import-jxinject-module,import the module>>.

[[import-jxinject-module]]
==== Import the module.

In your kodein binding configuration add the `jxInjectorModule`

[source, kotlin]
.Example: importing the JxInjector module
----
val kodein = Kodein {
    import(jxInjectorModule)
    /* Other bindings */
}
----


=== JavaX injections

==== Constructor injection

You can create a new instance of a given class, provided that:

- The class has only one constructor
- Or the class have one of its constructors annotated with `@Inject`.

It is a good practice, however, to always have an `@Inject` constructor, even if it is the only constructor.

.Example: Java class that can be automatically created with injections
[source, java]
----
public class MyJavaController {
    @Inject
    public MyJavaController(Connection connection, FileSystem fs) {
        /* ... */
    }
    /* ... */
}
----

You can then create instances of such classes by using `kodein.jx` in Kotlin, or `Jx.of(kodein)` in Java.

.Example: Creating a new instance in Kotlin
[source, kotlin]
----
val controller = kodein.jx.newInstance<MyJavaController>()
----

.Example: Creating a new instance in Java
[source, java]
----
MyJavaController controller = Jx.of(kodein).newInstance(MyJavaController.class);
----

==== Field injection

You can inject fields of a class by annotating them with `@Inject`.

.Example: Java class whose fields can be automatically injected.
[source, java]
----
public class MyJavaController {
    @Inject
    Connection connection;

    @Inject
    FileSystem fs;

    /* ... */
}
----

You can then inject existing instances of such classes by using `kodein.jx` in Kotlin, or `Jx.of(kodein)` in Java.

.Example: Injecting an existing instance in Kotlin
[source, kotlin]
----
val controller = MyJavaController()
kodein.jx.inject(controller)
----

.Example: Injecting an existing instance in Java
[source, java]
----
MyJavaController controller = new MyJavaController();
Jx.of(kodein).inject(controller);
----

==== Method injection

WARNING: Method injection is supported to be compatible with Java injection libraries.
         It is, however, widely considered as the less semantic injection method.

You can have `@Inject` annotated mehtod be called at injection.

.Example: Java class whose method will be automatically called on injection.
[source, java]
----
public class MyJavaController {
    @Inject
    public setIO(Connection connection, FileSystem fs) {
        /* ... */
    }
    /* ... */
}
----

You know the drill, use `kodein.jx` in Kotlin or `Jx.of(kodein)` in Java the exact same way as for field injection.


=== Being specific

==== Qualifiers annotations

`javax.inject` libraries use the concept of "qualifier annotations", which serves the same purpose as Kodein's tag system.

The `@Named` annotation is a qualifier provided by default, and is supported by default in Kodein-JxInject.
In Java, any field or method / constructor parameter annotated with `@Named("whatever")` will use the `String` value as tag.

.Example: Java class which uses named injection.
[source, java]
----
public class MyJavaController {
    @Inject @Named("SQL")
    Connection connection; <1>

    @Inject setConnection(@Named("SQL") Connection connection) { /*...*/ } <2>
}
----
<1>: Field injection.
<2>: Method injection.

To inject the `connection` field, Kodein will essentially retrive as `kodein.instance<Connection>(tag = "SQL")`.

For any other qualifier annotation, you need to provide a function that will transform a qualifier annotation to a tag.

.Example: Registering a qualifier annotation
[source, kotlin]
----
val kodein = Kodein {
    import(jxInjectorModule)

    /* Other bindings */

    jxQualifier<MyQualifier> { MyTag(it.value) } <1>
}
----
<1>: Transforms a `MyQualifier` qualifier annotation into a `MyTag` Kodein tag.

==== Using erased bindings

If you need to inject erased binding, you can annotate the field or method / constructor parameter with the `@ErasedBinding` annotation.

.Example: Java class which uses erased binding injection.
[source, java]
----
public class MyJavaController {
    @Inject @ErasedBinding List<Connection> connections;
}
----

==== Optionnal injection

If you need to inject something only if it was bound (and set it to null otherwise), you can use the `@OrNull` annotation.

.Example: Java class which uses nullable injection.
[source, java]
----
public class MyJavaController {
    @Inject @OrNull Connection connectionOrNull;
}
----

==== Provider & Factory injection

You can inject a provider, either by using `javax.inject.Provider` or `kotlin.jvm.functions.Function0`.
Note that if you are using the latter, you need to use the `@ProviderFun` annotation.

.Example: Java class which uses provider injection.
[source, java]
----
public class MyJavaController {
    @Inject Provider<Connection> connectionJXProvider;
    @Inject @ProviderFun Function0<Connection> connectionKotlinProvider;
}
----

To inject a factory, you need to use `kotlin.jvm.functions.Function1` annotated with `@FactoryFun`.

.Example: Java class which uses factory injection.
[source, java]
----
public class MyJavaController {
    @Inject @ProviderFun Function0<String, Connection> connectionFactory;
}
----


== Advanced use

=== OnReady callbacks

You can define callbacks to be called once the kodein instance is ready and all bindings are defined.
This can be useful to do some "starting" jobs.

[source, kotlin]
.Example: registering a callback at binding time
----
val appModule = Kodein.Module {
    import(engineModule)
    onReady {
        val engine = instance<Engine>()
        instance<Logger>().info("Starting engine version ${engine.version}")
        engine.start()
    }
}
----


=== Create your own scopes

==== Scoped singletons

Scoped singleton are singletons that are bound to a context and live while that context exists.

To define a scope that can contain scoped singleton, you must define an object that implements the `Scope` interface.
This object will be responsible for providing a `ScopeRegistry` according to a context.
It should always return the same `ScopeRegistry` when given the same context object.
Standard ways of doing so is to use the `userData` property of the context, if it has one, or else to use a `WeakHashMap<C, ScopeRegistry>`.

To declare bindings in your scope, use `scopedSingleton`.

[source, kotlin]
.Example: defining a scope and binding a singleton inside it
----
object myScope: Scope<Request> { // <1>
    override fun getRegistry(context: Request): ScopeRegistry
            = context.userData.getOrPut("registry") { ScopeRegistry() } as ScopeRegistry // <2>
}
----
<1> The scope's context type is `Request`.
<2> Creates a `ScopeRegistry` in the context `Request` if there is none.

==== Auto Scoped singletons

Scoped singletons are not always ideal since you need the context to retrieve any object.
Sometimes, the context is static.
For these times, you can use an "auto scoped singleton".
An auto scoped singleton is responsible for fetching both the `ScopeRegistry` and the context.

To define an auto scope that can contain auto scoped singleton, you must define an object that implements the `AutoScope` interface.

To declare bindings in your scope, use `autoScopedSingleton`.

[source, kotlin]
.Example: defining an scope and binding a singleton inside it
----
object myScope: AutoScope<Request> { // <1>
    override fun getRegistry(context: Request): ScopeRegistry
            = context.userData.getOrPut("registry") { ScopeRegistry() } as ScopeRegistry // <2>
    override fun getContext(): Request
            = StaticContext.getCurrentRequest() // <3>
}
----
<1> The scope's context type is `Request`.
<2> Same as `Scope.getRegistry`.
<3> Get the context from a static environment.

[TIP]
====
If your auto scope does not depends on a context, and always yields the same `ScopeRegistry`, then it's very simple:

.Example: defining a static auto scope
----
object myScope: AutoScope<Unit> {
    private val _registry = ScopeRegistry()
    override fun getRegistry(context: Unit) = _registry
    override fun getContext() = Unit
}
----
====

==== Bindings

A binding function is an extension function to `Kodein.Builder` that returns a `Binding<A, T>`.
If your scope is a provider scope (such as singleton), you can use the `NoArgBinding<T>` interface for ease of use.
Have a look at existing bindings in the https://github.com/SalomonBrys/Kodein/blob/{branch}/kodein/src/main/kotlin/com/github/salomonbrys/kodein/factories.kt[factories.kt] file.
The `singleton` binding function is very easy to understand and is a good starting point.


[[jvm-performance]]
=== Performance for the JVM

NOTE: To be clear, this section do not apply to JavaScript!

==== The type erasure problem

By default, Kodein is immune to type erasure, meaning that `bind<List<String>>()` and `bind<List<Int>>()` will represent two different bindings. +
Similarly, `kodein.instance<List<String>>()` and `kodein.instance<List<Int>>()` will yield two different list.

To be erasure immune, Kodein relies heavily on the `generic` function, which is known to be slow.

To improve performance, you can use the `erased` function with Kodein, which are faster, but do suffer from type erasure!

[WARNING]
====
Yes, #perfmatters. However, the humble opinion of the author is that:

- There is a balance to be found between performance, readability, security and debuggability.
- Optimisation is important *in critical path*, not _everywhere_.
- Kodein is already pretty optimized ;)
- In the vast majority of cases, using the `erased` function will result in **no significant performance change** to your application, as IoC is not a performance pitfall!

Therefore, please make sure that, using the `erased` function is right for your use case, before blindly using it ;).
*Do profile your code*!
====

==== Using generic and erased function forms

Each kodein function that handles a type exists in two form: as inline (lowercased first letter) and as regular function (uppercased first letter). +
For example, the `kodein.instance` function also exists as `kodein.Instance`.

The uppercase functions need `TypeToken` parameters that define the type being bound / retrieved and maybe the factory's argument. +
You can easily use these functions with the `generic` or `erased` functions:

[source, kotlin]
.Example: using the `erased` function
----
val ds: DataSource = kodein.Instance(erased())
----

By default, all inline functions are aliases to their uppercase counterparts using the `generic` function. +
For example, the `kodein.instance()` function is an alias to `kodein.Instance(generic())`

So, when you know that you inject a type that is *not generic*, you can use `kodein.Instance(erased())`.

[[erased-comp]]
==== Erased parameterized generic types

When using the `erased` function or using erased by default (either by choice on the JVM or forced on JavaScript), you cannot represent a generic type. +
For example, `erased<Set<String>>` will yield a `TypeToken` representing `Set<*>`.

Kodein provides a way to represent a generic type in an erased way:

[source, kotlin]
.Example: generic type tokens, using erased
----
erasedComp1<Set<String>, String>                         // Represents a Set<String>
erasedComp2<Map<Int, String>, Int, String>               // Represents a Map<Int, String>
erasedComp3<Triple<Int, String, Int>, Int, String, Int>  // Represents a Triple<Int, String, Int>
----

NOTE: The type parameter themselves are erased, meaning that you cannot represent a multi-level generic type.
      You can, however, construct your own `CompositeTypeToken` to represent such a type.

[[erased-by-default]]
==== Using erased by default

WARNING: Profile your code before using this, as this is very likely to bring no performance improvement to your application.

If you know what you are doing, and *_why_* you are doing it, you can change the default methods to alias with the `erased` function.

For this, you *must not* depend on the `kodein` module, and instead, depend on the `kodein-erased` module.

CAUTION: This means that, by default, `kodein.instance<List<String>>()` will look for an erased `List` binding. +
         Therefore, to bind a `List<String>` you *must* use `Bind<List<String>>(generic())`, and to retrieve it, you *must* use `kodein.Instance(generic())`.

NOTE: The inline function set that alias with the `erased` function is located in a different package than the regular one: `com.github.salomonbrys.kodein.erased`.


=== Bind the same type to different factories

Yeah, when I said earlier that "you can have multiple bindings of the same type, as long as they are bound with different tags", I lied.
Because each binding is actually a _factory_, the bindings are not `([BindType], [Tag])` but actually `([BindType], [ArgType], [Tag])` (note that providers and singletons are bound as `([BindType], Unit, [Tag])`).
This means that any combination of these three information can be bound to it's own factory, which in turns means that you can bind the same type without tagging to different factories.

CAUTION: Please be cautious when using this knowledge, as other less thorough readers may get confused with it.


=== Use the container API

The KodeinContainer is the sacred Kodein object that contains all bindings and is responsible for retrieval.
You can access it with `kodein.container`.
In it, each `Binding` is bound to a `Kodein.Key`.

In fact, all Kodein functions are proxies to this container API.

When defining bindings, in the `Kodein.Builder`, you can access the `container` property to bind factories to a `Kodein.Key` or a `Kodein.Bind`.


=== Explore bindings

You can access a *copy* of the bindings map with `kodein.container.bindings`. +
From this `Map<Kodein.Key, Factory<*, *>>`, you can explore all bindings, their keys and factories.

TIP: The https://github.com/SalomonBrys/Kodein/blob/{branch}/kodein/src/main/kotlin/com/github/salomonbrys/kodein/bindings.kt[bindings.kt] file exposes several extension functions to this map that can be useful for exploring it.


=== API reference

The API reference can be found https://github.com/SalomonBrys/Kodein/blob/{branch}/dokka/out/doc/index.md[here]!


== Get involved!

=== Contribute

Contributions are very welcome and greatly appreciated! The great majority of pull requests are eventually merged.

To contribute, simply fork https://github.com/SalomonBrys/Kodein[the project on Github], fix whatever is iching you, and submit a pull request!

I am sure that this documentation contains typos, inaccuracies and languages error (English is not my mother tongue).
If you feel like enhancing this document, you can propose a pull request that modifies https://github.com/SalomonBrys/Kodein/blob/{branch}/README3.adoc[README3.adoc].
(The documentation page is auto-generated from it).


=== Let's talk!

You've read so far?! *You're awesome!* +
Why don't you drop by the https://kotlinlang.slack.com/messages/kodein/[Kodein Slack channel] on Kotlin's Slack group?


=== Donate

Kodein is free to use for both non-profit and commercial use and always will be.

If you wish to show some support or appreciation to my work, you are free to *https://donorbox.org/donation-salomonbrys[donate]*!

TIP: This would be (of course) greatly appreciated but is by no means necessary to receive help or support, which I'll be happy to provide for free!
